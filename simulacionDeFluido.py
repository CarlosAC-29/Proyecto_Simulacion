# -*- coding: utf-8 -*-
"""Simulacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iUED0HuvxyqxYfx4sjjINIXf3ROny5ai
"""

import numpy as np
import math
import matplotlib.pyplot as plt;
from mpl_toolkits.mplot3d import Axes3D;


#Velocidad Inicial
v0=1
#h = magnitud en la que recorremos la matriz
h=1
#Ancho malla
nx= 100
#Alto malla
ny= 10
#matriz U
U = np.zeros((ny,nx), float)
W = np.zeros((ny,nx), float)
xInicial =  np.zeros((ny,nx), float)
#velocidad inicial 
v0 = 1
# Viga 1
inicio = 69
alto1 = 3
ancho1 = 30
# Viga 2
inicio2 = 28
alto2 = 3
ancho2 = 35
#b inicial
bu = np.zeros(nx*ny)
bw = np.zeros(nx*ny)
#x inicial metodos
xu = np.zeros(nx*ny)
xw = np.zeros(nx*ny)
#  Tolerancuia
tolerancia = 0.001
#  Sobrerelajacion
omegaX = 1.2

for i in range(nx * ny):
   bu[i] = h/8
   bw[i] = 0




def inicializar():
    for i in range(ny):
        V = 1
        for j in range(nx):
          if(i+1 > 1 and i+1 < ny and j == 0):
            xInicial[i][j] = V
          else:  
            xInicial[i][j] = round(V - 0.001, 3)
            V = V - 0.001
            if(i == 0 or i == ny-1 or j == nx-1):
              xInicial[i][j] = 0  


inicializar()
def rellenar(m1,flag):
  if(flag == 'x0'):
    for i in range(0, alto1):
        for j in range(inicio, inicio + ancho1):
            m1[i, j] = 0

    for i in range(ny-alto2, ny):
         for j in range(inicio2, inicio2 + ancho2):
             m1[i, j] = 0
  else:
    for i in range(0, alto1):
        for j in range(inicio, inicio + ancho1):
            m1[i, j] = 1

    for i in range(ny-alto2, ny):
         for j in range(inicio2, inicio2 + ancho2):
             m1[i, j] = 1               

rellenar(U, 'bu')
rellenar(xInicial, 'x0')

def array(u,i,j):
    
    fila = np.zeros((ny,nx))
    
    fila[i,j] = 1
    if(j == 0):       
        fila[i,j+1] =  - 1/4 - (1/8*u[i,j])   
    elif(j+1 >= nx):
        fila[i,j-1] = - 1/4 + (1/8*u[i,j])  
    else:
        fila[i,j+1] = - 1/4 - (1/8*u[i,j]) 
        fila[i,j-1] = - 1/4 + (1/8*u[i,j]) 

    if(i == 0):
        fila[i+1,j] = -1/4 
    elif(i+1 >= ny):
        fila[i-1,j] = -1/4
    else:
        fila[i+1,j] = -1/4
        fila[i-1,j] = -1/4  
  
        
    return fila
    

def concatArrays(arr):
    fila = []
    for i in range(ny):
        fila = np.concatenate((fila, arr[i]), axis=None)
    return fila 

def jacobiana():
    matriz = []
    for i in range(ny):
      fila = []
      for j in range(nx):
        fila = concatArrays(array(xInicial,i,j))
        matriz.append(fila) 
    return matriz

#CALCULO DE JACOBIANA 
def Mostrar(m):
    i=-1
    j=-1
    print("La matriz es la siguiente:")
    for fila in m:   
        for valor in fila:
            print("\t", valor, end=" ")
        print()


################## CONDICIONES DE FORNTERA PARA EL X INICIAL   #################
# Viga superior
def viga1 (m):
## H
  for i in range(ny):
    for j in range(nx):
      if(j == inicio-1 and (i >= 0 and i < alto1)):
        m[i][j] = 0
## I
  for i in range(ny):
    for j in range(nx):
      if(j == inicio and i == alto1):
        m[i][j] = 0
        

# Viga inferior
def viga2 (m):
## D
  for i in range(ny):
    for j in range(nx):
      if(j == inicio2-1 and (i >= ny-alto2 and i < ny)):
        m[i][j] = 0
## C
  for i in range(ny):
    for j in range(nx):
      if(j >= inicio2 and j < (inicio2+ancho2) and i == ny-(alto2+1)):
        m[i][j] = 0       
## B
  for i in range(ny):
    for j in range(nx):
      if(j == inicio2+ancho2 and (i >= ny-alto2 and i < ny)):
        m[i][j] = 0  

##### LLAMADO
# viga1(xInicial)   
# viga2(xInicial)        
#Mostrar(jacobiana())
#print(U)
# Mostrar(xInicial)
# ## En U localizamos las vigas
# Mostrar(U)
x0 = xInicial.reshape(-1)
#print(bw)

"""**CONDICIONES DE FRONTERA**"""

def inlet(b,malla):
  if(malla == 'u'):
    for i in range(nx,nx*ny,nx):
      b[i] = 1
    else:
      b[i] = 0    

  return b

inlet(bu,"u")
inlet(bu,"w")
#print(bu)

def surfaceG(b, malla):
  if(malla == 'u'):
    for i in range(nx):
      b[i] = 0  
    else:
      b[i] = 0  
  return  b 

surfaceG(bu,"u")
surfaceG(bu,"w")
#print(bu)

def centerline(b,malla):
  if(malla == 'u'):
    for i in range((nx*ny)-nx,nx*ny):
      b[i] = 0
    else:
      b[i] = 0
  return b   

centerline(bu,"u")
centerline(bw,"w")
# print(bu)

def outlet(b,malla):
  if(malla == "u"):
    for i in range(nx-1,nx*ny,nx):
      b[i] = 0
    else:
      b[i] = 0
  return b  

outlet(bu,"u")
outlet(bw,"w")
#print(bu)

def obstaculos(b, m, viga):
  malla = m.reshape(-1)
  if(viga == 'u'):
    for i in range (nx*ny):
      if(malla[i] == 1):
        b[i] = 0
  else:
    for i in range (nx*ny):
      if(malla[i] == 1):
        b[i] = 0

obstaculos(bu, U, 'u')
obstaculos(bw, U, 'w')
#print(bu)

# Viga superior
def viga1 (m, viga):
  mallaU = np.reshape(bu, (ny, nx))
  malla = np.reshape(m, (ny, nx))
  if(viga == "u"):
  ## H
    for i in range(ny):
      for j in range(nx):
        if(j == inicio-1 and (i >= 0 and i < alto1)):
          malla[i][j] = 0
  ## I
    for i in range(ny):
      for j in range(nx):
        if((j >= inicio and j < nx) and i == alto1):
          malla[i][j] = 0
          
def viga1W (m,vec):
  mallaU = np.reshape(vec, (ny, nx))
  malla = np.reshape(m, (ny, nx))
      ## H
  for i in range(1,ny):
    for j in range(nx):
      if(j == inicio-1 and (i >= 0 and i < alto1)):
        malla[i][j] = 2*(mallaU[i][j-1] - mallaU[i][j]) / (h**2)
## I
  for i in range(1,ny):
    for j in range(nx):
      if((j >= inicio and j < nx) and i == alto1):
        malla[i][j] = 2*(mallaU[i+1][j] - mallaU[i][j]) / (h**2)


  malla = malla.reshape(-1)

  return malla      

viga1(bu, "u")      

# Viga inferior
def viga2 (m,viga):
  mallaU = np.reshape(bu, (ny, nx))
  malla = np.reshape(m, (ny, nx))
  if(viga == "u"):
  ## D
    for i in range(ny):
      for j in range(nx):
        if(j == inicio2-1 and (i >= ny-alto2 and i < ny)):
          malla[i][j] = 0
  ## C
    for i in range(ny):
      for j in range(nx):
        if(j >= inicio2 and j < (inicio2+ancho2) and i == ny-(alto2+1)):
          malla[i][j] = 0       
  ## B
    for i in range(ny):
      for j in range(nx):
        if(j == inicio2+ancho2 and (i >= ny-alto2 and i < ny)):
          malla[i][j] = 0  


  malla = malla.reshape(-1)

  return malla

def viga2W (m,vec):
  mallaU = np.reshape(vec, (ny, nx))
  malla = np.reshape(m, (ny, nx))
## D
  for i in range(ny-1):
    for j in range(nx):
      if(j == inicio2-1 and (i >= ny-alto2 and i < ny)):
        malla[i][j] = 2*(mallaU[i][j-1] - mallaU[i][j]) / (h**2)
## C
  for i in range(ny):
    for j in range(nx):
      if(j >= inicio2 and j < (inicio2+ancho2) and i == ny-(alto2+1)):
          malla[i][j] = 2*(mallaU[i-1][j] - mallaU[i][j]) / (h**2) 
## B
  for i in range(ny-1):
    for j in range(nx):
      if(j == inicio2+ancho2 and (i >= ny-alto2 and i < ny)):
          malla[i][j] = 2*(mallaU[i][j+1] - mallaU[i][j]) / (h**2)

  malla = malla.reshape(-1)

  return malla

viga2(bu, "u")
 


matrizJacobiana = jacobiana()

matrizU = np.reshape(bu, (ny, nx))
matrizW = np.reshape(bw, (ny, nx))


def fronterasJac():
  for i in range(nx*ny):
    if(bu[i] == 0 or bu[i] == 1):
      matrizJacobiana[i] = np.zeros(nx*ny, float)

def diagonalDom(jac):
  for i in range(nx*ny):
    for j in range(nx*ny):
      if(i == j):
        jac[i][j] = 1

def isDDM(m, n) :
 
    for i in range(0, n) :        
        sum = 0
        for j in range(0, n) :
            sum = sum + abs(m[i][j])    
        sum = sum - abs(m[i][i])
        if (abs(m[i][i]) < sum) :
            return i,i
 
    return True     

def isSymmetric(mat, N):
    for i in range(N):
        for j in range(N):
            if (mat[i][j] != mat[j][i]):
                return False
    return True   

     
fronterasJac()
diagonalDom(matrizJacobiana)   
#Mostrar(matrizJacobiana)
#print(bu)
print("Es la matriz diagonalmente dominante? : ",isDDM(matrizJacobiana,ny*nx))
print("Es la matriz simetrica? : ",isSymmetric(matrizJacobiana,ny*nx))
# print('matriz U')
# Mostrar(matrizU)  
# print('matriz W')
# Mostrar(matrizW)

def gausSeidel(A,x,b,N):
  tamano = np.shape(A)
  n = tamano[0]
  m = tamano[1]
  #  valores iniciales
  X = np.copy(x)
  diferencia = np.ones(n, dtype=float)
  errado = 2*tolerancia

  itera = 0
  while not(errado<=tolerancia or itera>N):
    Xcopy= np.copy(X)
    # por fila
    for i in range(0,n,1):
        # por columna
        suma = 0 
        for j in range(0,m,1):
            # excepto diagonal de A
            if (i!=j): 
                suma = suma- A[i][j]*X[j]
        
        nuevo = (b[i]+suma)/A[i][i]
        diferencia[i] = np.abs(nuevo-X[i])
        X[i] = nuevo
    errado = np.max(diferencia)
    itera = itera + 1
  X = np.transpose([X])
#  print('Converge en: ',itera)

  return X

def gradient_conjugate(jac, x, b , max_iter):
    A = np.transpose(jac)
    g = np.dot(A.T, np.dot(A, x) - b)
    p = -g
    for i in range(max_iter):
        alpha = -np.dot(g.T, p) / np.dot(p.T, np.dot(A, p))
        x = x + alpha * p
        g = np.dot(A.T, np.dot(A, x) - b)
        beta = np.dot(g.T, g) / np.dot(p.T, np.dot(A, p))
        p = -g + beta * p
        if np.linalg.norm(g) < tolerancia:
          #print("Convergi en :", i)
          break
    return x



def newtonRaphson(A,x,b,M,j):
  xi = x
  for i in range(0,M):
    X = np.copy(xi)
    deltax = gausSeidel(A,xi,b,j)
    xi = (1-omegaX)*X+omegaX*deltax.reshape(-1)   
    diff = np.linalg.norm(np.abs(xi) - np.abs(X))
    if(diff<= tolerancia):
      print("Normal:", diff)
      print("Converge en:", i)
      break
  return xi

#vectortSolucion = gradient_conjugate(matrizJacobiana, x0, bu, 85)
#vectortSolucionU = gausSeidel(matrizJacobiana, x0, bu, 80)
vectortSolucionU = newtonRaphson(matrizJacobiana, x0, bu, 80,80)
maxVec = np.amax(vectortSolucionU)
newVecU = np.reshape(vectortSolucionU,(ny,nx))
for i in range(ny):
  for j in range(nx):
    if(j != 0):
      newVecU[i][j] = newVecU[i][j]/maxVec
viga1W(bw,vectortSolucionU)
viga2W(bw,vectortSolucionU)
vectortSolucionW = newtonRaphson(matrizJacobiana, x0, bw, 80, 80)
#vectortSolucionW = gausSeidel(matrizJacobiana, x0, bw, 80)
matrizSolucionU = np.reshape(newVecU, (ny, nx))
maxSpeed = np.amax(matrizSolucionU)
print(maxSpeed)
matrizSolucionW = np.reshape(vectortSolucionW, (ny, nx))
# print("Esta es la matriz U")
# Mostrar(matrizSolucionU)
# print("Esta es la matriz W")
# Mostrar(matrizSolucionW)

magnU = np.zeros((ny, nx))
magnW = np.zeros((ny, nx))
magnSum = np.zeros((ny, nx))

for i in range(ny):
    for j in range(nx):
        magnU[i][j] = abs(matrizSolucionU[i][j])

for i in range(ny):
    for j in range(nx):
        magnW[i][j] = abs(matrizSolucionW[i][j])
        
for i in range(ny):
    for j in range(nx):
        magnSum[i][j] = abs(matrizSolucionW[i][j] + matrizSolucionU[i][j])
        
maxSum = np.amax(magnSum)

for i in range(ny):
    for j in range(nx):
      if(j != 0):
        magnSum[i][j] = magnSum[i][j]/maxSum

x = np.linspace(0, nx - 1, nx)
y = np.linspace(0, ny - 1, ny)

xmesh, ymesh = np.meshgrid(x, y)

umesh = U

print("u")
plt.imshow(magnU)
plt.colorbar()
#plt.quiver(xmesh, umesh)
plt.show()

print("W")
plt.imshow(magnW)
plt.colorbar()
#plt.quiver(xmesh, umesh)
plt.show()

print("Sum")
plt.imshow(magnSum)
plt.colorbar()
plt.show()

x = range(0, nx)
y = range(0, ny)
X, Y = np.meshgrid(x, y)

def functz(u):
  z = u[Y, X]
  return z

Z = functz(magnSum)

fig = plt.figure()
ax = Axes3D(fig)
ax.plot_wireframe(X, Y, Z, color = 'r')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Stream Function')
plt.show()

from scipy.interpolate import RectBivariateSpline

x = range(0, nx)
y = range(0, ny)
z = magnSum
X, Y = np.meshgrid(x, y)
spl = RectBivariateSpline(y, x, z)

zi = spl(y, x)


fig = plt.figure()
axe = Axes3D(fig)
axe.view_init(30, -240)
axe.plot_surface(X, Y, zi, cmap='inferno')

axe.invert_xaxis()

axe.set_xlabel('X')
axe.set_ylabel('Y')
axe.set_zlabel('Z')